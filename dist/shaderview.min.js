/*! @keithclark/shaderview v1.0.0 - Keith Clark - MIT license */
const e=new Map;class t extends HTMLElement{#e;#t;#s;#r;#a;#i;#n;#h;#o=null;#d=0;#l=0;#m=!0;#c=!1;#p=new ResizeObserver((()=>{this.#v("resize",{width:this.clientWidth,height:this.clientHeight})}));#u=new MutationObserver((()=>{this.#g()}));#S=new IntersectionObserver((e=>{this.#c=e[0].isIntersecting;const[t]=e,{target:s,isIntersecting:r}=t;r?(this.#p.observe(s),this.#m?this.#v("setTime",this.#l):(this.#v("setTime",performance.now()/1e3-this.#d),this.#v("pause",!1))):(this.#p.unobserve(s),this.#m||this.#v("pause",!0))}));constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="<style>\n@layer {:host { width: 400px; height: 300px; display: inline-block }}\ndiv { position: relative; height: 100%; width:100%; user-select: none; overflow:hidden }\ncanvas { position: absolute; inset:0 }\n</style><div><canvas></canvas><slot/></div>",this.#t=this.shadowRoot.querySelector("canvas").transferControlToOffscreen(),this.#e=new Worker(`${import.meta.url}/../shaderview-worker.min.js`),this.#v("setCanvas",this.#t,[this.#t]),this.shadowRoot.querySelector("slot").hidden=!0}#v(e,t,s){this.#e.postMessage({cmd:e,data:t},s)}#b(){this.paused||this.pause(),this.#v("dispose")}async#w(e,t){const s=await fetch(e,{priority:"low",signal:t});if(!s.ok)throw new Error("HTTP Error");return s.text()}async#f(t,s){if(!e.has(t)){let r;r=t.hasAttribute("src")?await this.#w(t.src,s):t.text,e.set(t,r)}return e.get(t)}async#g(){const e=this.querySelector('script[type="x-shader/x-fragment"]'),t=this.querySelector('script[type="x-shader/x-vertex"]');if(this.#a!==e||this._vertexShaderElem!==t){if(this.#a!==e&&(this.#a&&(this.#s?.abort(),this.#n=null),e&&(this.#s=new AbortController,this.#n=this.#f(e,this.#s.signal)),this.#a=e),this.#i!==t&&(this.#i&&(this.#r?.abort(),this.#h=null),t?(this.#r=new AbortController,this.#h=this.#f(t,this.#r.signal)):this.#h="attribute vec3 position;void main(){gl_Position=vec4(position,1);}",this.#i=t),!this.#n)return this.#b(),void(this.#o=null);this.#o=Promise.all([this.#n,this.#h]).then((([e,t])=>{this.#b(),this.#v("setSource",{fragmentSource:e,vertexSource:t})}));try{await this.#o,this.dispatchEvent(new Event("load")),this.hasAttribute("autoplay")&&this.play()}catch(e){"AbortError"!==e.name&&(this.#b(),this.#o=null,this.dispatchEvent(new Event("error")))}}}connectedCallback(){this.#g(),this.#u.observe(this,{childList:!0}),this.#S.observe(this)}disconnectedCallback(){this.#p.disconnect(),this.#u.disconnect(),this.#S.disconnect()}get paused(){return this.#m}get time(){return this.#l}set time(e){this.#d=performance.now()/1e3-e,this.#l=e,this.#c&&this.#v("setTime",e)}get autoplay(){return this.hasAttribute("autoplay")}set autoplay(e){this.toggleAttribute("autoplay",!!e)}get fragmentShader(){return this.#a}get vertexShader(){return this.#i}async play(){if(this.#m){if(!this.#o)throw new DOMException("InvalidStateError");try{await this.#o}catch(e){throw new DOMException("DataError")}this.#d=performance.now()/1e3-this.#l,this.#v("pause",!1),this.#m=!1,this.dispatchEvent(new Event("playing"))}}pause(){this.#m||(this.#m=!0,this.#v("pause",!0),this.dispatchEvent(new Event("pause")))}}export{t as default};
