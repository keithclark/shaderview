/*! @keithclark/shaderview v1.0.0 - Keith Clark - MIT license */
const e=(e,t,r,s)=>{e.postMessage({cmd:t,data:r},s)},t=(t,r,s,a=[])=>new Promise(((i,n)=>{const h=new MessageChannel;h.port1.onmessage=e=>{"ok"===e.data.status?i():n(new DOMException(e.data.reason||"Unhandled worker error"))},e(t,r,s,[h.port2,...a])})),r=new Map;class s extends HTMLElement{#e;#t;#r;#s;#a;#i;#n;#h;#o=null;#d=null;#m=0;#c=0;#l=!0;#p=!1;#v=new ResizeObserver((()=>{e(this.#e,"resize",{width:this.clientWidth,height:this.clientHeight})}));#u=new MutationObserver((()=>{this.#w()}));#g=new IntersectionObserver((t=>{this.#p=t[0].isIntersecting;const[r]=t,{target:s,isIntersecting:a}=r;a?(this.#v.observe(s),this.#l?e(this.#e,"setTime",this.#c):(e(this.#e,"setTime",performance.now()/1e3-this.#m),e(this.#e,"pause",!1))):(this.#v.unobserve(s),this.#l||e(this.#e,"pause",!0))}));constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="<style>\n@layer {:host { width: 400px; height: 300px; display: inline-block }}\ndiv { position: relative; height: 100%; width:100%; user-select: none; overflow:hidden }\ncanvas { position: absolute; inset:0 }\n</style><div><canvas></canvas><slot hidden /></div>",this.#e=new Worker(`${import.meta.url}/../shaderview-worker.min.js`),this.#t=this.shadowRoot.querySelector("canvas").transferControlToOffscreen(),this.#d=t(this.#e,"setCanvas",this.#t,[this.#t]),this.#d.catch((e=>{this.shadowRoot.querySelector("slot").hidden=!1}))}#S(){this.paused||this.pause(),this.#p=!1,this.#v.disconnect(),this.#g.disconnect(),e(this.#e,"dispose")}async#b(e,t){const r=await fetch(e,{priority:"low",signal:t});if(!r.ok)throw new Error("HTTP Error");return r.text()}async#f(e,t){if(!r.has(e)){let s;s=e.hasAttribute("src")?await this.#b(e.src,t):e.text,r.set(e,s)}return r.get(e)}async#w(){const e=this.querySelector('script[type="x-shader/x-fragment"]'),r=this.querySelector('script[type="x-shader/x-vertex"]');if(this.#a!==e||this._vertexShaderElem!==r){if(this.#a!==e&&(this.#a&&(this.#r?.abort(),this.#n=null),e&&(this.#r=new AbortController,this.#n=this.#f(e,this.#r.signal)),this.#a=e),this.#i!==r&&(this.#i&&(this.#s?.abort(),this.#h=null),r?(this.#s=new AbortController,this.#h=this.#f(r,this.#s.signal)):this.#h="attribute vec3 position;void main(){gl_Position=vec4(position,1);}",this.#i=r),!this.#n)return this.#S(),void(this.#o=null);this.#o=Promise.all([this.#n,this.#h,this.#d]).then((([e,r])=>(this.#S(),t(this.#e,"setSource",{fragmentSource:e,vertexSource:r}))));try{await this.#o,this.#g.observe(this),this.#v.observe(this),this.dispatchEvent(new Event("load")),this.hasAttribute("autoplay")&&this.play()}catch(e){"AbortError"!==e.name&&(this.#S(),this.#o=null,this.dispatchEvent(new Event("error")))}}}connectedCallback(){this.#w(),this.#u.observe(this,{childList:!0})}disconnectedCallback(){this.#S(),this.#u.disconnect()}get paused(){return this.#l}get time(){return this.#l?this.#c:performance.now()/1e3-this.#m}set time(t){this.#m=performance.now()/1e3-t,this.#c=t,this.#p&&e(this.#e,"setTime",t)}get autoplay(){return this.hasAttribute("autoplay")}set autoplay(e){this.toggleAttribute("autoplay",!!e)}get fragmentShader(){return this.#a}get vertexShader(){return this.#i}async play(){if(this.#l){if(!this.#o)throw new DOMException("InvalidStateError");try{await this.#o}catch(e){throw new DOMException("DataError")}this.#m=performance.now()/1e3-this.#c,e(this.#e,"pause",!1),this.#l=!1,this.dispatchEvent(new Event("playing"))}}pause(){this.#l||(this.#c=performance.now()/1e3-this.#m,this.#l=!0,e(this.#e,"pause",!0),this.dispatchEvent(new Event("pause")))}}export{s as default};
