/*! @keithclark/shaderview v1.0.0 - Keith Clark - MIT license */
class e extends Error{constructor(e,t=""){super(e),console.error(e+"\n  "+t.replace(/\n/g,"\n  "))}}class t{#e;#t;#r;#i=0;#s=0;#a=0;constructor(e,t,r){this.#e=e,this.#t=this.#n(t,r),this.#r=this.#h(this.#t)}#o(t,r){const i=this.#e,s=i.createShader(r);if(i.shaderSource(s,t),i.compileShader(s),!i.getShaderParameter(s,i.COMPILE_STATUS))throw new e(`Shader compilation failed (SHADER_TYPE=${r})`,i.getShaderInfoLog(s));return s}#n(t,r){const i=this.#e;i.clearColor(1,1,1,0);const s=this.#o(r,i.VERTEX_SHADER),a=this.#o(t,i.FRAGMENT_SHADER),n=i.createProgram();if(i.attachShader(n,s),i.attachShader(n,a),i.linkProgram(n),!i.getProgramParameter(n,i.LINK_STATUS))throw new e("Program link failed",i.getProgramInfoLog(n));i.useProgram(n);const h=new Float32Array([1,1,-1,1,1,-1,-1,-1]),o=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,o),i.bufferData(i.ARRAY_BUFFER,h,i.STATIC_DRAW);const d=i.getAttribLocation(n,"position");return i.enableVertexAttribArray(d),i.vertexAttribPointer(d,2,i.FLOAT,!1,0,0),n}#h=e=>{const t=new Map,r=this.#e,i=r.getProgramParameter(e,r.ACTIVE_UNIFORMS);for(let s=0;s<i;s++){const{type:i,name:a}=r.getActiveUniform(e,s),n=r.getUniformLocation(e,a);let h;h=i===r.BOOL?e=>r.uniform1i(n,e?1:0):i===r.FLOAT?e=>r.uniform1f(n,e):i===r.FLOAT_VEC2?(...e)=>r.uniform2f(n,...e):i===r.FLOAT_VEC3?(...e)=>r.uniform3f(n,...e):i===r.FLOAT_VEC4?(...e)=>r.uniform4f(n,...e):i===r.INT?e=>r.uniform1i(n,e):i===r.INT_VEC2?(...e)=>r.uniform2i(n,...e):i===r.INT_VEC3?(...e)=>r.uniform3i(n,...e):i===r.INT_VEC4?(...e)=>r.uniform4i(n,...e):()=>{console.warn(`Uniform "${a}" is an unsupported type ${i}.`)},t.set(a,h)}return t};render(){const e=this.#e,{canvas:t}=e,{clientWidth:r,clientHeight:i}=t;this.#i===r&&this.#s===i||(this.#i=r,this.#s=i,e.viewport(0,0,r,i),this.#d("uResolution",r,i)),e.drawArrays(e.TRIANGLE_STRIP,0,4)}dispose(){const e=this.#e;e.clear(e.COLOR_BUFFER_BIT),e.deleteProgram(this.#t)}setTime(e){this.#a=e,this.#d("uTime",this.#a)}#d(e,...t){this.#r.get(e)?.(...t)}setUniform(t,...r){if(!this.#r.has(t))throw new e("Error setting uniform",`Uniform "${t}" does not exist.`);this.#d(t,...r)}}const r=new Map;class i extends HTMLElement{#m;#l;#c;#u;#p;#f;#g;#S;#v=null;#E=null;#w=null;#A=null;#x=0;#y=0;#T=!0;#b=!0;#R=new ResizeObserver((()=>{this.#T=!0,this.#F()}));#I=new MutationObserver((()=>{this.#C()}));constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="<style>\n@layer {:host { width: 400px; height: 300px; display: inline-block }}\ndiv { position: relative; height: 100%; width:100%; user-select: none }\ncanvas { position: absolute; inset:0 }\n</style><div><canvas></canvas><slot/></div>",this.#l=this.shadowRoot.querySelector("canvas"),this.#m=this.#l.getContext("webgl"),this.#m&&(this.shadowRoot.querySelector("slot").hidden=!0)}#O(){this.paused||this.pause(),this.#v&&(this.#v.dispose(),this.#v=null)}async#U(e,t){const r=await fetch(e,{priority:"low",signal:t});if(!r.ok)throw new Error("HTTP Error");return r.text()}async#P(e,t){if(!r.has(e)){let i;i=e.hasAttribute("src")?await this.#U(e.src,t):e.text,r.set(e,i)}return r.get(e)}async#C(){const e=this.querySelector('script[type="x-shader/x-fragment"]'),r=this.querySelector('script[type="x-shader/x-vertex"]');if(this.#p!==e||this._vertexShaderElem!==r){if(this.#p!==e&&(this.#p&&(this.#c?.abort(),this.#g=null),e&&(this.#c=new AbortController,this.#g=this.#P(e,this.#c.signal)),this.#p=e),this.#f!==r&&(this.#f&&(this.#u?.abort(),this.#S=null),r?(this.#u=new AbortController,this.#S=this.#P(r,this.#u.signal)):this.#S="attribute vec3 position;void main(){gl_Position=vec4(position,1);}",this.#f=r),!this.#g)return this.#O(),void(this.#A=null);this.#A=Promise.all([this.#g,this.#S]).then((([e,r])=>{this.#O(),this.#v=new t(this.#m,e,r)}));try{await this.#A,this.dispatchEvent(new Event("load")),this.hasAttribute("autoplay")?this.play():this.#F()}catch(e){"AbortError"!==e.name&&(this.#O(),this.#A=null,this.dispatchEvent(new Event("error")))}}}connectedCallback(){this.#C(),this.#R.observe(this),this.#I.observe(this,{childList:!0})}disconnectedCallback(){this.#R.disconnect(),this.#I.disconnect()}#F(){null===this.#w&&(this.#w=requestAnimationFrame((()=>{this.#v&&this.#_(),this.#w=null})))}#_(){this.#T&&(this.#l.width=this.clientWidth,this.#l.height=this.clientHeight,this.#T=!1),this.#v.setTime(this.#y),this.#v.render()}#L(e){this.#y=e,this.#F()}get paused(){return this.#b}get time(){return this.#y}set time(e){this.#x=performance.now()/1e3-e,this.#L(e)}get autoplay(){return this.hasAttribute("autoplay")}set autoplay(e){this.toggleAttribute("autoplay",!!e)}async play(){if(!this.#b)return;if(!this.#A)throw new DOMException("InvalidStateError");try{await this.#A}catch(e){throw new DOMException("DataError")}this.#b=!1,this.#x=performance.now()/1e3-this.#y;const e=()=>{this.#L(performance.now()/1e3-this.#x),this.#E=requestAnimationFrame(e)};e(),this.dispatchEvent(new Event("playing"))}pause(){this.#b||(this.#b=!0,cancelAnimationFrame(this.#E),this.dispatchEvent(new Event("pause")))}}export{i as default};
