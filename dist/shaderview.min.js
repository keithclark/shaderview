/*! @keithclark/shaderview v1.0.0 - Keith Clark - MIT license */
class e extends Error{constructor(e,t=""){super(e),console.error(e+"\n  "+t.replace(/\n/g,"\n  "))}}class t{#e;#t;#r;#s=0;#i=0;constructor(e,t,r){this.#e=e,this.#t=this.#a(t,r),this.#r=this.#n(this.#t)}#h(t,r){const s=this.#e,i=s.createShader(r);if(s.shaderSource(i,t),s.compileShader(i),!s.getShaderParameter(i,s.COMPILE_STATUS))throw new e(`Shader compilation failed (SHADER_TYPE=${r})`,s.getShaderInfoLog(i));return i}#a(t,r){const s=this.#e;s.clearColor(1,1,1,0);const i=this.#h(r,s.VERTEX_SHADER),a=this.#h(t,s.FRAGMENT_SHADER),n=s.createProgram();if(s.attachShader(n,i),s.attachShader(n,a),s.linkProgram(n),!s.getProgramParameter(n,s.LINK_STATUS))throw new e("Program link failed",s.getProgramInfoLog(n));s.useProgram(n);const h=new Float32Array([1,1,-1,1,1,-1,-1,-1]),o=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,o),s.bufferData(s.ARRAY_BUFFER,h,s.STATIC_DRAW);const d=s.getAttribLocation(n,"position");return s.enableVertexAttribArray(d),s.vertexAttribPointer(d,2,s.FLOAT,!1,0,0),n}#n=e=>{const t=new Map,r=this.#e,s=r.getProgramParameter(e,r.ACTIVE_UNIFORMS);for(let i=0;i<s;i++){const{type:s,name:a}=r.getActiveUniform(e,i),n=r.getUniformLocation(e,a);let h;h=s===r.BOOL?e=>r.uniform1i(n,e?1:0):s===r.FLOAT?e=>r.uniform1f(n,e):s===r.FLOAT_VEC2?(...e)=>r.uniform2f(n,...e):s===r.FLOAT_VEC3?(...e)=>r.uniform3f(n,...e):s===r.FLOAT_VEC4?(...e)=>r.uniform4f(n,...e):s===r.INT?e=>r.uniform1i(n,e):s===r.INT_VEC2?(...e)=>r.uniform2i(n,...e):s===r.INT_VEC3?(...e)=>r.uniform3i(n,...e):s===r.INT_VEC4?(...e)=>r.uniform4i(n,...e):()=>{console.warn(`Uniform "${a}" is an unsupported type ${s}.`)},t.set(a,h)}return t};render(){const e=this.#e,{canvas:t}=e,{clientWidth:r,clientHeight:s}=t;this.#s===r&&this.#i===s||(this.#s=r,this.#i=s,e.viewport(0,0,r,s),this.#o("uResolution",r,s)),e.drawArrays(e.TRIANGLE_STRIP,0,4)}dispose(){const e=this.#e;e.clear(e.COLOR_BUFFER_BIT),e.deleteProgram(this.#t)}setTime(e){this.#o("uTime",e)}#o(e,...t){this.#r.get(e)?.(...t)}setUniform(t,...r){if(!this.#r.has(t))throw new e("Error setting uniform",`Uniform "${t}" does not exist.`);this.#o(t,...r)}}const r=new Map;class s extends HTMLElement{#d;#m;#l;#c;#u;#p;#g;#f;#S=null;#v=null;#E=null;#w=null;#A=0;#x=0;#y=!0;#T=!0;#b=new ResizeObserver((()=>{this.#y=!0,this.#R()}));#F=new MutationObserver((()=>{this.#I()}));constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="<style>\n@layer {:host { width: 400px; height: 300px; display: inline-block }}\ndiv { position: relative; height: 100%; width:100%; user-select: none }\ncanvas { position: absolute; inset:0 }\n</style><div><canvas></canvas><slot/></div>",this.#m=this.shadowRoot.querySelector("canvas"),this.#d=this.#m.getContext("webgl"),this.#d&&(this.shadowRoot.querySelector("slot").hidden=!0)}#C(){this.paused||this.pause(),this.#S&&(this.#S.dispose(),this.#S=null)}async#O(e,t){const r=await fetch(e,{priority:"low",signal:t});if(!r.ok)throw new Error("HTTP Error");return r.text()}async#U(e,t){if(!r.has(e)){let s;s=e.hasAttribute("src")?await this.#O(e.src,t):e.text,r.set(e,s)}return r.get(e)}async#I(){const e=this.querySelector('script[type="x-shader/x-fragment"]'),r=this.querySelector('script[type="x-shader/x-vertex"]');if(this.#u!==e||this._vertexShaderElem!==r){if(this.#u!==e&&(this.#u&&(this.#l?.abort(),this.#g=null),e&&(this.#l=new AbortController,this.#g=this.#U(e,this.#l.signal)),this.#u=e),this.#p!==r&&(this.#p&&(this.#c?.abort(),this.#f=null),r?(this.#c=new AbortController,this.#f=this.#U(r,this.#c.signal)):this.#f="attribute vec3 position;void main(){gl_Position=vec4(position,1);}",this.#p=r),!this.#g)return this.#C(),void(this.#w=null);this.#w=Promise.all([this.#g,this.#f]).then((([e,r])=>{this.#C(),this.#S=new t(this.#d,e,r)}));try{await this.#w,this.dispatchEvent(new Event("load")),this.hasAttribute("autoplay")?this.play():this.#R()}catch(e){"AbortError"!==e.name&&(this.#C(),this.#w=null,this.dispatchEvent(new Event("error")))}}}connectedCallback(){this.#I(),this.#b.observe(this),this.#F.observe(this,{childList:!0})}disconnectedCallback(){this.#b.disconnect(),this.#F.disconnect()}#R(){null===this.#E&&(this.#E=requestAnimationFrame((()=>{this.#S&&this.#P(),this.#E=null})))}#P(){this.#y&&(this.#m.width=this.clientWidth,this.#m.height=this.clientHeight,this.#y=!1),this.#S.setTime(this.#x),this.#S.render()}#_(e){this.#x=e,this.#R()}get paused(){return this.#T}get time(){return this.#x}set time(e){this.#A=performance.now()/1e3-e,this.#_(e)}get autoplay(){return this.hasAttribute("autoplay")}set autoplay(e){this.toggleAttribute("autoplay",!!e)}get fragmentShader(){return this.#u}get vertexShader(){return this.#p}async play(){if(!this.#T)return;if(!this.#w)throw new DOMException("InvalidStateError");try{await this.#w}catch(e){throw new DOMException("DataError")}this.#T=!1,this.#A=performance.now()/1e3-this.#x;const e=()=>{this.#_(performance.now()/1e3-this.#A),this.#v=requestAnimationFrame(e)};e(),this.dispatchEvent(new Event("playing"))}pause(){this.#T||(this.#T=!0,cancelAnimationFrame(this.#v),this.dispatchEvent(new Event("pause")))}}export{s as default};
