/*! @keithclark/shaderview v1.0.0 - Keith Clark - MIT license */
const e=(e,t,r,s)=>{e.postMessage({cmd:t,data:r},s)},t=(t,r,s,n=[])=>new Promise(((i,a)=>{const o=new MessageChannel;o.port1.onmessage=e=>{"ok"===e.data.status?i():a(new DOMException(e.data.reason||"Unhandled worker error"))},e(t,r,s,[o.port2,...n])})),r=new Map;class s extends HTMLElement{#e;#t;#r;#s;#n;#i;#a;#o;#h=null;#c=null;#d=0;#m=0;#l=!0;#u=!1;#p=new ResizeObserver((()=>{e(this.#e,"resize",{width:this.clientWidth,height:this.clientHeight})}));#f=new MutationObserver((()=>{this.#g()}));#w=new IntersectionObserver((t=>{this.#u=t[0].isIntersecting;const[r]=t,{target:s,isIntersecting:n}=r;n?(this.#p.observe(s),this.#l?e(this.#e,"setTime",this.#m):(e(this.#e,"setTime",performance.now()/1e3-this.#d),e(this.#e,"pause",!1))):(this.#p.unobserve(s),this.#l||e(this.#e,"pause",!0))}));constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="<style>\n@layer {:host { width: 400px; height: 300px; display: inline-block }}\ndiv { position: relative; height: 100%; width:100%; user-select: none; overflow:hidden }\ncanvas { position: absolute; inset:0 }\n</style><div><canvas></canvas><slot hidden /></div>",this.#e=new Worker(URL.createObjectURL(new Blob(['class e extends Error{constructor(e,t=""){super(e),console.error(e+"\\n  "+t.replace(/\\n/g,"\\n  "))}}class t{#e;#t;#r;constructor(e,t,r){if(!e instanceof WebGLRenderingContext)throw new Error("Argument 1 must be a WebGLRenderingContext");this.#e=e,this.#t=this.#n(t,r),this.#r=this.#o(this.#t)}#a(t,r){const n=this.#e,o=n.createShader(r);if(n.shaderSource(o,t),n.compileShader(o),!n.getShaderParameter(o,n.COMPILE_STATUS))throw new e(`Shader compilation failed (SHADER_TYPE=${r})`,n.getShaderInfoLog(o));return o}#n(t,r){const n=this.#e;n.clearColor(1,1,1,0);const o=this.#a(r,n.VERTEX_SHADER),a=this.#a(t,n.FRAGMENT_SHADER),i=n.createProgram();if(n.attachShader(i,o),n.attachShader(i,a),n.linkProgram(i),!n.getProgramParameter(i,n.LINK_STATUS))throw new e("Program link failed",n.getProgramInfoLog(i));n.useProgram(i);const s=new Float32Array([1,1,-1,1,1,-1,-1,-1]),c=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,c),n.bufferData(n.ARRAY_BUFFER,s,n.STATIC_DRAW);const m=n.getAttribLocation(i,"position");return n.enableVertexAttribArray(m),n.vertexAttribPointer(m,2,n.FLOAT,!1,0,0),i}#o=e=>{const t=new Map,r=this.#e,n=r.getProgramParameter(e,r.ACTIVE_UNIFORMS);for(let o=0;o<n;o++){const{type:n,name:a}=r.getActiveUniform(e,o),i=r.getUniformLocation(e,a);let s;s=n===r.BOOL?e=>r.uniform1i(i,e?1:0):n===r.FLOAT?e=>r.uniform1f(i,e):n===r.FLOAT_VEC2?(...e)=>r.uniform2f(i,...e):n===r.FLOAT_VEC3?(...e)=>r.uniform3f(i,...e):n===r.FLOAT_VEC4?(...e)=>r.uniform4f(i,...e):n===r.INT?e=>r.uniform1i(i,e):n===r.INT_VEC2?(...e)=>r.uniform2i(i,...e):n===r.INT_VEC3?(...e)=>r.uniform3i(i,...e):n===r.INT_VEC4?(...e)=>r.uniform4i(i,...e):()=>{console.warn(`Uniform "${a}" is an unsupported type ${n}.`)},t.set(a,s)}return t};render(){const e=this.#e,{canvas:t}=e,{width:r,height:n}=t;e.viewport(0,0,r,n),this.#i("uResolution",r,n),e.drawArrays(e.TRIANGLE_STRIP,0,4)}dispose(){const e=this.#e;e.clear(e.COLOR_BUFFER_BIT),e.deleteProgram(this.#t)}setTime(e){this.#i("uTime",e)}#i(e,...t){this.#r.get(e)?.(...t)}setUniform(t,...r){if(!this.#r.has(t))throw new e("Error setting uniform",`Uniform "${t}" does not exist.`);this.#i(t,...r)}}const r=e=>{e.postMessage({status:"ok"})},n=(e,t)=>{e.postMessage({status:"fail",reason:t})};let o,a,i,s=null,c=null,m=0,f=0,l=0,h=0;self.onmessage=e=>{const{cmd:s,data:c}=e.data,[u]=e.ports;if("setCanvas"===s){a=c;try{i=a.getContext("webgl"),r(u)}catch(e){n(u,"Unable to obtain a WebGL context")}}else if("setSource"===s)try{o=new t(i,c.fragmentSource,c.vertexSource),r(u),scheduleRender()}catch(e){o=null,n(u,e.message)}else if("resize"===s)m=c.width,f=c.height,scheduleRender();else if("pause"===s)!0===c?g():d();else if("setTime"===s)h=c,l=performance.now()/1e3-h,scheduleRender();else if("dispose"===s){if(!o)return;cancelRender(),g(),o.dispose(),o=null}},cancelRender=()=>{cancelAnimationFrame(s),s=null},scheduleRender=()=>{s||(s=requestAnimationFrame((()=>{s=null,u()})))};const u=()=>{o&&(m===a.width&&f===a.height||(a.width=m,a.height=f),o.setTime(h),o.render())},d=()=>{if(c)return;l=performance.now()/1e3-h;const e=()=>{h=performance.now()/1e3-l,scheduleRender(),c=requestAnimationFrame(e)};e()},g=()=>{cancelAnimationFrame(c),c=null};\n']))),this.#t=this.shadowRoot.querySelector("canvas").transferControlToOffscreen(),this.#c=t(this.#e,"setCanvas",this.#t,[this.#t]),this.#c.catch((e=>{this.shadowRoot.querySelector("slot").hidden=!1}))}#v(){this.paused||this.pause(),this.#u=!1,this.#p.disconnect(),this.#w.disconnect(),e(this.#e,"dispose")}async#S(e,t){const r=await fetch(e,{priority:"low",signal:t});if(!r.ok)throw new Error("HTTP Error");return r.text()}async#b(e,t){if(!r.has(e)){let s;s=e.hasAttribute("src")?await this.#S(e.src,t):e.text,r.set(e,s)}return r.get(e)}async#g(){const e=this.querySelector('script[type="x-shader/x-fragment"]'),r=this.querySelector('script[type="x-shader/x-vertex"]');if(this.#n!==e||this._vertexShaderElem!==r){if(this.#n!==e&&(this.#n&&(this.#r?.abort(),this.#a=null),e&&(this.#r=new AbortController,this.#a=this.#b(e,this.#r.signal)),this.#n=e),this.#i!==r&&(this.#i&&(this.#s?.abort(),this.#o=null),r?(this.#s=new AbortController,this.#o=this.#b(r,this.#s.signal)):this.#o="attribute vec3 position;void main(){gl_Position=vec4(position,1);}",this.#i=r),!this.#a)return this.#v(),void(this.#h=null);this.#h=Promise.all([this.#a,this.#o,this.#c]).then((([e,r])=>(this.#v(),t(this.#e,"setSource",{fragmentSource:e,vertexSource:r}))));try{await this.#h,this.#w.observe(this),this.#p.observe(this),this.dispatchEvent(new Event("load")),this.hasAttribute("autoplay")&&this.play()}catch(e){"AbortError"!==e.name&&(this.#v(),this.#h=null,this.dispatchEvent(new Event("error")))}}}connectedCallback(){this.#g(),this.#f.observe(this,{childList:!0})}disconnectedCallback(){this.#v(),this.#f.disconnect()}get paused(){return this.#l}get time(){return this.#l?this.#m:performance.now()/1e3-this.#d}set time(t){this.#d=performance.now()/1e3-t,this.#m=t,this.#u&&e(this.#e,"setTime",t)}get autoplay(){return this.hasAttribute("autoplay")}set autoplay(e){this.toggleAttribute("autoplay",!!e)}get fragmentShader(){return this.#n}get vertexShader(){return this.#i}async play(){if(this.#l){if(!this.#h)throw new DOMException("InvalidStateError");try{await this.#h}catch(e){throw new DOMException("DataError")}this.#d=performance.now()/1e3-this.#m,e(this.#e,"pause",!1),this.#l=!1,this.dispatchEvent(new Event("playing"))}}pause(){this.#l||(this.#m=performance.now()/1e3-this.#d,this.#l=!0,e(this.#e,"pause",!0),this.dispatchEvent(new Event("pause")))}}export{s as default};
