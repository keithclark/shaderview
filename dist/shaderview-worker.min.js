/*! @keithclark/shaderview v1.1.1 - Keith Clark - MIT license */
class e extends Error{constructor(e,t=""){super(e),console.error(e+"\n  "+t.replace(/\n/g,"\n  "))}}class t{#e;#t;#r;constructor(e,t,r){if(!e instanceof WebGLRenderingContext)throw new Error("Argument 1 must be a WebGLRenderingContext");this.#e=e,this.#t=this.#n(t,r),this.#r=this.#o(this.#t)}#a(t,r){const n=this.#e,o=n.createShader(r);if(n.shaderSource(o,t),n.compileShader(o),!n.getShaderParameter(o,n.COMPILE_STATUS))throw new e(`Shader compilation failed (SHADER_TYPE=${r})`,n.getShaderInfoLog(o));return o}#n(t,r){const n=this.#e;n.clearColor(1,1,1,0);const o=this.#a(r,n.VERTEX_SHADER),a=this.#a(t,n.FRAGMENT_SHADER),i=n.createProgram();if(n.attachShader(i,o),n.attachShader(i,a),n.linkProgram(i),!n.getProgramParameter(i,n.LINK_STATUS))throw new e("Program link failed",n.getProgramInfoLog(i));n.useProgram(i);const s=new Float32Array([1,1,-1,1,1,-1,-1,-1]),c=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,c),n.bufferData(n.ARRAY_BUFFER,s,n.STATIC_DRAW);const m=n.getAttribLocation(i,"position");return n.enableVertexAttribArray(m),n.vertexAttribPointer(m,2,n.FLOAT,!1,0,0),i}#o=e=>{const t=new Map,r=this.#e,n=r.getProgramParameter(e,r.ACTIVE_UNIFORMS);for(let o=0;o<n;o++){const{type:n,name:a}=r.getActiveUniform(e,o),i=r.getUniformLocation(e,a);let s;s=n===r.BOOL?e=>r.uniform1i(i,e?1:0):n===r.FLOAT?e=>r.uniform1f(i,e):n===r.FLOAT_VEC2?(...e)=>r.uniform2f(i,...e):n===r.FLOAT_VEC3?(...e)=>r.uniform3f(i,...e):n===r.FLOAT_VEC4?(...e)=>r.uniform4f(i,...e):n===r.INT?e=>r.uniform1i(i,e):n===r.INT_VEC2?(...e)=>r.uniform2i(i,...e):n===r.INT_VEC3?(...e)=>r.uniform3i(i,...e):n===r.INT_VEC4?(...e)=>r.uniform4i(i,...e):()=>{console.warn(`Uniform "${a}" is an unsupported type ${n}.`)},t.set(a,s)}return t};render(){const e=this.#e,{canvas:t}=e,{width:r,height:n}=t;e.viewport(0,0,r,n),this.#i("uResolution",r,n),e.drawArrays(e.TRIANGLE_STRIP,0,4)}dispose(){const e=this.#e;e.clear(e.COLOR_BUFFER_BIT),e.deleteProgram(this.#t)}setTime(e){this.#i("uTime",e)}#i(e,...t){this.#r.get(e)?.(...t)}setUniform(t,...r){if(!this.#r.has(t))throw new e("Error setting uniform",`Uniform "${t}" does not exist.`);this.#i(t,...r)}}const r=e=>{e.postMessage({status:"ok"})},n=(e,t)=>{e.postMessage({status:"fail",reason:t})};let o,a,i,s=null,c=null,m=0,f=0,l=0,h=0;self.onmessage=e=>{const{cmd:s,data:c}=e.data,[u]=e.ports;if("setCanvas"===s){a=c;try{i=a.getContext("webgl"),r(u)}catch(e){n(u,"Unable to obtain a WebGL context")}}else if("setSource"===s)try{o=new t(i,c.fragmentSource,c.vertexSource),r(u),scheduleRender()}catch(e){o=null,n(u,e.message)}else if("resize"===s)m=c.width,f=c.height,scheduleRender();else if("pause"===s)!0===c?g():d();else if("setTime"===s)h=c,l=performance.now()/1e3-h,scheduleRender();else if("dispose"===s){if(!o)return;cancelRender(),g(),o.dispose(),o=null}},cancelRender=()=>{cancelAnimationFrame(s),s=null},scheduleRender=()=>{s||(s=requestAnimationFrame((()=>{s=null,u()})))};const u=()=>{o&&(m===a.width&&f===a.height||(a.width=m,a.height=f),o.setTime(h),o.render())},d=()=>{if(c)return;l=performance.now()/1e3-h;const e=()=>{h=performance.now()/1e3-l,scheduleRender(),c=requestAnimationFrame(e)};e()},g=()=>{cancelAnimationFrame(c),c=null};
