/*! shaderview v1.0.0 - Keith Clark - MIT license */
class e extends Error{constructor(e,t=""){super(e),console.error(e+"\n  "+t.replace(/\n/g,"\n  "))}}class t{#e;#t;#r;#s=0;#i=0;#a=0;constructor(e,t,r){this.#e=e,this.#t=this.#n(t,r),this.#r=this.#h(this.#t)}#o(t,r){const s=this.#e,i=s.createShader(r);if(s.shaderSource(i,t),s.compileShader(i),!s.getShaderParameter(i,s.COMPILE_STATUS))throw new e(`Shader compilation failed (SHADER_TYPE=${r})`,s.getShaderInfoLog(i));return i}#n(t,r){const s=this.#e;s.clearColor(1,1,1,0);const i=this.#o(r,s.VERTEX_SHADER),a=this.#o(t,s.FRAGMENT_SHADER),n=s.createProgram();if(s.attachShader(n,i),s.attachShader(n,a),s.linkProgram(n),!s.getProgramParameter(n,s.LINK_STATUS))throw new e("Program link failed",s.getProgramInfoLog(n));s.useProgram(n);const h=new Float32Array([1,1,-1,1,1,-1,-1,-1]),o=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,o),s.bufferData(s.ARRAY_BUFFER,h,s.STATIC_DRAW);const d=s.getAttribLocation(n,"position");return s.enableVertexAttribArray(d),s.vertexAttribPointer(d,2,s.FLOAT,!1,0,0),n}#h=e=>{const t=new Map,r=this.#e,s=r.getProgramParameter(e,r.ACTIVE_UNIFORMS);for(let i=0;i<s;i++){const{type:s,name:a}=r.getActiveUniform(e,i),n=r.getUniformLocation(e,a);let h;h=s===r.BOOL?e=>r.uniform1i(n,e?1:0):s===r.FLOAT?e=>r.uniform1f(n,e):s===r.FLOAT_VEC2?(...e)=>r.uniform2f(n,...e):s===r.FLOAT_VEC3?(...e)=>r.uniform3f(n,...e):s===r.FLOAT_VEC4?(...e)=>r.uniform4f(n,...e):s===r.INT?e=>r.uniform1i(n,e):s===r.INT_VEC2?(...e)=>r.uniform2i(n,...e):s===r.INT_VEC3?(...e)=>r.uniform3i(n,...e):s===r.INT_VEC4?(...e)=>r.uniform4i(n,...e):()=>{console.warn(`Uniform "${a}" is an unsupported type ${s}.`)},t.set(a,h)}return t};render(){const e=this.#e,{canvas:t}=e,{clientWidth:r,clientHeight:s}=t;this.#s===r&&this.#i===s||(this.#s=r,this.#i=s,e.viewport(0,0,r,s),this.#d("uResolution",r,s)),e.drawArrays(e.TRIANGLE_STRIP,0,4)}dispose(){const e=this.#e;e.clear(e.COLOR_BUFFER_BIT),e.deleteProgram(this.#t)}setTime(e){this.#a=e,this.#d("uTime",this.#a)}#d(e,...t){this.#r.get(e)?.(...t)}setUniform(t,...r){if(!this.#r.has(t))throw new e("Error setting uniform",`Uniform "${t}" does not exist.`);this.#d(t,...r)}}const r=new Map;class s extends HTMLElement{#m;#l;#c;#u;#g;#p;#f;#S;#v=null;#E=null;#w=null;#A=null;#x=0;#y=0;#T=!0;#b=!0;#R=new ResizeObserver((()=>{this.#T=!0,this.#F()}));#I=new MutationObserver((()=>{this.#C()}));constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="<style>\n@layer {:host { width: 400px; height: 300px; display: inline-block }}\ndiv { position: relative; height: 100%; width:100%; user-select: none }\ncanvas { position: absolute; inset:0 }\n</style><div><canvas></canvas><slot/></div>",this.#l=this.shadowRoot.querySelector("canvas"),this.#m=this.#l.getContext("webgl"),this.#m&&(this.shadowRoot.querySelector("slot").hidden=!0)}#O(){this.paused||this.pause(),this.#v&&(this.#v.dispose(),this.#v=null)}async#U(e,t){const r=await fetch(e,{priority:"low",signal:t});if(!r.ok)throw new Error("HTTP Error");return r.text()}async#P(e,t){if(!r.has(e)){let s;s=e.hasAttribute("src")?await this.#U(e.src,t):e.text,r.set(e,s)}return r.get(e)}async#C(){const e=this.querySelector('script[type="x-shader/x-fragment"]'),r=this.querySelector('script[type="x-shader/x-vertex"]');if(this.#g!==e||this._vertexShaderElem!==r){if(this.#g!==e&&(this.#g&&(console.log("removing current fragment shader"),this.#c?.abort(),this.#f=null),e&&(console.log("adding new fragment shader"),this.#c=new AbortController,this.#f=this.#P(e,this.#c.signal)),this.#g=e),this.#p!==r&&(this.#p&&(console.log("removing current vertex shader"),this.#u?.abort(),this.#S=null),r?(console.log("adding new vertex shader"),this.#u=new AbortController,this.#S=this.#P(r,this.#u.signal)):this.#S="attribute vec3 position;void main(){gl_Position=vec4(position,1);}",this.#p=r),!this.#f)return this.#O(),void(this.#A=null);this.#A=Promise.all([this.#f,this.#S]).then((([e,r])=>{this.#O(),this.#v=new t(this.#m,e,r)}));try{await this.#A,this.dispatchEvent(new Event("load")),this.hasAttribute("autoplay")?this.play():this.#F()}catch(e){"AbortError"!==e.name&&(this.#O(),this.#A=null,this.dispatchEvent(new Event("error")))}}else console.log("nochange")}connectedCallback(){this.#C(),this.#R.observe(this),this.#I.observe(this,{childList:!0})}disconnectedCallback(){this.#R.disconnect(),this.#I.disconnect()}#F(){null===this.#w&&(this.#w=requestAnimationFrame((()=>{this.#v&&this.#_(),this.#w=null})))}#_(){this.#T&&(this.#l.width=this.clientWidth,this.#l.height=this.clientHeight,this.#T=!1),this.#v.setTime(this.#y),this.#v.render()}#L(e){this.#y=e,this.#F()}get paused(){return this.#b}get time(){return this.#y}set time(e){this.#x=performance.now()/1e3-e,this.#L(e)}get autoplay(){return this.hasAttribute("autoplay")}set autoplay(e){this.toggleAttribute("autoplay",!!e)}async play(){if(!this.#b)return;if(!this.#A)throw new DOMException("InvalidStateError");try{await this.#A}catch(e){throw new DOMException("DataError")}this.#b=!1,this.#x=performance.now()/1e3-this.#y;const e=()=>{this.#L(performance.now()/1e3-this.#x),this.#E=requestAnimationFrame(e)};e(),this.dispatchEvent(new Event("playing"))}pause(){this.#b||(this.#b=!0,cancelAnimationFrame(this.#E),this.dispatchEvent(new Event("pause")))}}export{s as default};
