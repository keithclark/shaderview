{"version":3,"file":"shaderview.js","sources":["../src/worker-utils.js","../src/ShaderviewElement.js"],"sourcesContent":["const WORKER_STATUS_SUCCESS = 'ok';\nconst WORKER_STATUS_FAILURE = 'fail';\n\n\n/**\n * @param {Worker} worker The web worker instance responsible for process the command\n * @param {string} cmd The command to execute\n * @param {*} data The command payload\n * @param {Transferable[]} transfer Objects to be transfered to the worker\n */\nexport const executeCommand = (worker, cmd, data, transfer) => {\n  worker.postMessage({ cmd, data }, transfer);\n};\n\n\n/**\n * @param {Worker} worker The web worker instance responsible for process the command\n * @param {string} cmd The command to execute\n * @param {*} data The command payload\n * @param {Transferable[]} transfer Objects to be transfered to the worker\n * @returns {Promise<*>}\n */\nexport const executeCommandAsync = (worker, cmd, data, transfer = []) => {\n  return new Promise((resolve, reject) => {\n    const channel = new MessageChannel();\n    channel.port1.onmessage = (event) => {\n      //console.log(cmd,'response', event.data)\n      if (event.data.status === WORKER_STATUS_SUCCESS) {\n        resolve();\n      } else {\n        reject(new DOMException(event.data.reason || 'Unhandled worker error'));\n      }\n    };\n    executeCommand(worker, cmd, data, [channel.port2, ...transfer]);\n  });\n};\n\n\n/**\n * @param {MessagePort} port\n */\nexport const sendExecuteSuccess = (port) => {\n  port.postMessage({ status: WORKER_STATUS_SUCCESS });\n};\n\n\n/**\n * @param {MessagePort} port\n */\nexport const sendExecuteError = (port, reason) => {\n  port.postMessage({ status: WORKER_STATUS_FAILURE, reason });\n};\n","import { executeCommand, executeCommandAsync } from \"./worker-utils.js\";\n\nconst WORKER_FILENAME = 'shaderview-worker.js';\n\nconst CSS = `\n@layer {:host { width: 400px; height: 300px; display: inline-block }}\ndiv { position: relative; height: 100%; width:100%; user-select: none; overflow:hidden }\ncanvas { position: absolute; inset:0 }\n`;\n\nconst DEFAULT_VERTEX_SHADER_CODE = 'attribute vec3 position;void main(){gl_Position=vec4(position,1);}';\n\nconst shaderSourceMap = new Map();\n\n/**\n * A Web Component for rendering GLSL shaders in HTML documents. \n */\nexport default class HTMLShaderviewElement extends HTMLElement {\n\n  /** @type {Worker} */\n  #worker;\n\n  /** @type {HTMLCanvasElement} */\n  #canvas;\n\n  /** @type {AbortController?} */\n  #fragmentShaderAborter\n\n  /** @type {AbortController?} */\n  #vertexShaderAborter\n\n  /** @type {HTMLScriptElement?} */\n  #fragmentShaderElement;\n\n  /** @type {HTMLScriptElement?} */\n  #vertexShaderElement;\n\n  /** @type {Promise<string>?} */\n  #fragmentShader;\n\n  /** @type {Promise<string>?} */\n  #vertexShader;\n\n  /** @type {Promise<void>?} */\n  #ready = null;\n\n  /** @type {Promise<void>?} */\n  #canvasReady = null;\n\n  #startFrameTimestamp = 0;\n\n  #lastFrameTimestamp = 0;\n\n  #paused = true;\n  #intersecting = false;\n\n  #resizeObserver = new ResizeObserver(() => {\n    executeCommand(this.#worker, 'resize', {\n      width: this.clientWidth,\n      height: this.clientHeight\n    });\n  });\n\n  #mutationObserver = new MutationObserver(() => {\n    this.#initShaderFromDom();\n  });\n\n  #intersectionObserver = new IntersectionObserver((entries) => {\n    this.#intersecting = entries[0].isIntersecting;\n    const [ entry ] = entries;\n    const { target, isIntersecting } = entry;\n\n    if (isIntersecting) {\n      // Start monitoring the element for size changes. This will trigger a \n      // `setSize` message to the worker.\n      this.#resizeObserver.observe(target);\n\n      // If the ShaderElement isn't paused then we need to restart the worker \n      // and account for time difference.\n      if (!this.#paused) {\n        executeCommand(this.#worker, 'setTime', (performance.now() / 1000) - this.#startFrameTimestamp);\n        executeCommand(this.#worker, 'pause', false);\n      } else {\n        executeCommand(this.#worker, 'setTime', this.#lastFrameTimestamp);\n      }\n    } else {\n      // Stop monitoring for size changes and pause the worker if we're\n      // currently playing the shader.\n      this.#resizeObserver.unobserve(target);\n      if (!this.#paused) {\n        executeCommand(this.#worker, 'pause', true);\n      }\n    }\n  });\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.innerHTML = `<style>${CSS}</style><div><canvas></canvas><slot hidden /></div>`;\n    this.#worker = new Worker(`${import.meta.url}/../${WORKER_FILENAME}`);\n    this.#canvas = this.shadowRoot.querySelector('canvas').transferControlToOffscreen();\n    this.#canvasReady = executeCommandAsync(this.#worker, 'setCanvas', this.#canvas, [this.#canvas]);\n    this.#canvasReady.catch((e) => {\n      this.shadowRoot.querySelector('slot').hidden = false;\n      // The component isn't going to work so fail silently and render the fallback\n      // content\n    });\n\n  }\n\n\n  /**\n   * Stops playback, disposes the current renderer instance and deletes the \n   * ready promise.\n   */\n  #releaseRenderer() {\n    if (!this.paused) {\n      this.pause();\n    }\n    this.#intersecting = false;\n    this.#resizeObserver.disconnect();\n    this.#intersectionObserver.disconnect();\n    executeCommand(this.#worker, 'dispose');\n  }\n\n\n  /**\n   * Fetches text contents of a resource from a URL\n   * \n   * @param {string} url The url of the resource to fetch the contents for\n   * @param {AbortSignal} [signal] An abort signal for cancelling the request\n   * @returns {Promise<string>} The resource contents as a string\n   */\n  async #fetchExternalContents(url, signal) {\n    const res = await fetch(url, {\n      priority: 'low', \n      signal\n    });\n    if (!res.ok) {\n      throw new Error('HTTP Error');\n    }\n    return res.text();\n  }\n\n\n  /**\n   * Resolves the contents of a `<script>` element. If the element has a `src`\n   * attribute the contents will be downloaded, otherwise the text content of\n   * the element will be used. Resulting content is cached against the element.\n   * \n   * @param {string} url The url of the resource to fetch the contents for\n   * @param {AbortSignal} [signal] An abort signal for cancelling the request\n   * @returns {Promise<string>} The resource contents as a string\n   */\n  async #getScriptContents(scriptElem, signal) {\n    if (!shaderSourceMap.has(scriptElem)) {\n      let content;\n      if (scriptElem.hasAttribute('src')) {\n        content = await this.#fetchExternalContents(scriptElem.src, signal);\n      } else {\n        content = scriptElem.text;\n      }\n      shaderSourceMap.set(scriptElem, content)\n    }\n    return shaderSourceMap.get(scriptElem);\n  }\n\n\n  /**\n   * Generates a `SharderRenderer` for this element from child `<script>`  \n   * elements containing shader definitions. Only the first shader script of \n   * each type (`x-shader/x-fragment` or `x-shader/x-vertex`) is considered as a \n   * participant for the renderer, other script defintions are ignored.\n   * \n   * Whenever a new script becomes a participant or a particpating script is \n   * removed, a new renderer instance is created reflecting the new \n   * configuration. While shaders for the new renderer are resolving (network, \n   * compilation etc.) the existing renderer will continue to run. This allows a\n   * seemless transition between states.\n   * \n   * Once the shader is ready, a `load` event is dispatched. This event does not\n   * bubble and cannot be cancelled. If initialization fails for any reason a \n   * `load` event is dispatched.\n   */\n  async #initShaderFromDom() {\n\n    /** @type {HTMLScriptElement?} */\n    const fragmentShaderElem = this.querySelector('script[type=\"x-shader/x-fragment\"]');\n\n    /** @type {HTMLScriptElement?} */\n    const vertexShaderElem = this.querySelector('script[type=\"x-shader/x-vertex\"]');\n \n    if (this.#fragmentShaderElement === fragmentShaderElem && this._vertexShaderElem === vertexShaderElem) {\n      return;\n    }\n\n    // Are we replacing the fragment shader?\n    if (this.#fragmentShaderElement !== fragmentShaderElem) {\n      // If the previous renderer is still being initialized (e.g. slow network \n      // connection) then we abort it so that it doesn't resolve later and trash\n      // any new shaders.\n      if (this.#fragmentShaderElement) {\n        this.#fragmentShaderAborter?.abort();\n        this.#fragmentShader = null;\n      }\n\n      if (fragmentShaderElem) {\n        this.#fragmentShaderAborter = new AbortController();\n        this.#fragmentShader = this.#getScriptContents(fragmentShaderElem, this.#fragmentShaderAborter.signal);\n      }\n\n      this.#fragmentShaderElement = fragmentShaderElem;\n    }\n\n\n    // Are we replacing the vertex shader?\n    if (this.#vertexShaderElement !== vertexShaderElem) {\n      // If the previous renderer is still being initialized (e.g. slow network \n      // connection) then we abort it so that it doesn't resolve later and trash\n      // any new shaders.\n      if (this.#vertexShaderElement) {\n        this.#vertexShaderAborter?.abort();\n        this.#vertexShader = null;\n      }\n\n      if (vertexShaderElem) {\n        this.#vertexShaderAborter = new AbortController();\n        this.#vertexShader = this.#getScriptContents(vertexShaderElem, this.#vertexShaderAborter.signal);\n      } else {\n        this.#vertexShader = DEFAULT_VERTEX_SHADER_CODE;\n      }\n      this.#vertexShaderElement = vertexShaderElem;\n    }\n \n    // We we don't have a fragment shader then we can't render anything.\n    if (!this.#fragmentShader) {\n      this.#releaseRenderer();\n      this.#ready = null;\n      return;\n    }\n\n    // Ready is used elsewhere to determine if a renderer is available\n    this.#ready = Promise.all([\n      this.#fragmentShader,\n      this.#vertexShader,\n      this.#canvasReady\n    ]).then(([fragmentSource, vertexSource]) => {\n      this.#releaseRenderer();\n      return executeCommandAsync(this.#worker, 'setSource', {\n        fragmentSource,\n        vertexSource\n      });\n    });\n   \n  \n    // When the new shader has finished initialization we dispatch a `load` \n    // event and then schedule a render of the first frame or, if configured, \n    // start playback. If the initialization fails we raise a `error` event so \n    // the host application can act accordingly.\n    try {\n      await this.#ready;\n      this.#intersectionObserver.observe(this);\n      this.#resizeObserver.observe(this);\n\n      this.dispatchEvent(new Event('load'));\n      if (this.hasAttribute('autoplay')) {\n        this.play();\n      }\n    } catch (e) {\n      if (e.name !== 'AbortError') {\n        this.#releaseRenderer();\n        this.#ready = null;\n        this.dispatchEvent(new Event('error'));\n      }\n    }\n  }\n\n\n  /**\n   * @ignore\n   */\n  connectedCallback() {\n    this.#initShaderFromDom();\n    this.#mutationObserver.observe(this, { childList: true });\n  }\n\n\n  /**\n   * @ignore\n   */\n  disconnectedCallback() {\n    this.#releaseRenderer();\n    this.#mutationObserver.disconnect();\n  }\n\n\n  /**\n   * Returns a boolean that indicates whether the shader is paused.\n   * @type {boolean}\n   */\n  get paused() {\n    return this.#paused;\n  }\n\n\n  /**\n   * The current plackback time in seconds. \n   * \n   * _Note: During playback, the frame render time is controlled by the worker.\n   * To avoid over using `postMessage` to sync the time value with this element \n   * the worker value is approximated. This can result in a lack of precision._\n   * \n   * @type {number}\n   */\n  get time() {\n    if (this.#paused) {\n      return this.#lastFrameTimestamp;\n    }\n    return performance.now() / 1000 - this.#startFrameTimestamp;\n  }\n\n  set time(value) {\n    this.#startFrameTimestamp = (performance.now() / 1000) - value;\n    this.#lastFrameTimestamp = value;\n    if (this.#intersecting) {\n      executeCommand(this.#worker, 'setTime', value);\n    }\n  }\n\n\n  /**\n   * Reflects the `autoplay` HTML attribute, indicating whether playback should \n   * begin automatically once the shader is ready.\n   * @type {boolean} \n   */\n  get autoplay() {\n    return this.hasAttribute('autoplay');\n  }\n\n  set autoplay(value) {\n    this.toggleAttribute('autoplay', !!value);\n  }\n\n\n  /**\n   * Returns the `HTMLScriptElement` used as the fragment shader source or \n   * `null` if no fragment shader is configured.\n   * @type {HTMLScriptElement|null} \n   */\n  get fragmentShader() {\n    return this.#fragmentShaderElement;\n  }\n\n\n  /**\n   * Returns the `HTMLScriptElement` used as the vertex shader source or \n   * `null` if no fragment shader is configured.\n   * @type {HTMLScriptElement|null} \n   */\n  get vertexShader() {\n    return this.#vertexShaderElement;\n  }\n\n  /**\n   * Starts playback of the shader when it is ready. Returns a `Promise` that \n   * resolves when playback starts. Failure to begin playback for any reason\n   * will result in the promise being rejected.\n   * \n   * Once playback begins, a `playing` event is dispatched. This event does not\n   * bubble and cannot be cancelled.\n   * @returns {Promise<void>}\n   */\n  async play() {\n    if (!this.#paused) {\n      return;\n    }\n\n    if (!this.#ready) {\n      throw new DOMException('InvalidStateError');\n    }\n\n    try {\n      await this.#ready;\n    } catch (e) {\n      throw new DOMException('DataError');\n    }\n  \n    this.#startFrameTimestamp = (performance.now() / 1000) - this.#lastFrameTimestamp;\n\n    executeCommand(this.#worker, 'pause', false);\n    this.#paused = false;\n    this.dispatchEvent(new Event('playing'));\n  }\n\n\n  /**\n   * Pauses playback of the shader.\n   * \n   * Once playback stops, a `pause` event is dispatched. This event does not\n   * bubble and cannot be cancelled.\n   */\n  pause() {\n    if (this.#paused) {\n      return;\n    }\n    this.#lastFrameTimestamp = (performance.now() / 1000) - this.#startFrameTimestamp;\n    this.#paused = true;\n    executeCommand(this.#worker, 'pause', true);\n    this.dispatchEvent(new Event('pause'));\n  }\n\n}\n"],"names":[],"mappings":"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"}